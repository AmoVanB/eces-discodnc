v2.4.0
------
* JUnit5: minimal set of dependencies (only the JUnit5 libraries we use, remove hamcrest?)
* Merge Ant build files build.xml and DiscoDNCjar.xml
* OPERATIONS DISPATCHER CODE NOT FUNCTIONAL

v2.4.x
------
* Alternatives to store a delta_T curve --> Identify properly 
  - segment2.y == infty || segment2.rate == infty
* Alternatives to store other curves?

* Check -Next branch for ideas regarding improvement of the flow prolongation code.

* Use Curve's is_rate_latency and is_token_bucket in Convolution and Deconvolution --> Use a swtich to let it determine automatically?
* Rearrange the checks: Currently, there are checks in curves that are specific to limitations of our operators. We should separate both parts more from each other. 

* Test all part of an analysis' intermediate results as found in the documentation and *Results.
* In the tests: Create Num objects instead of AnalysisResults and let expected_results reuse previously created AnalysisResult objects internally.

* Check my MMB implementation: It only works for TB, RL where the output bound is TB as well, right? Because we reduce the deconvolution result's burstiness. That only works if we guarantee that both alternatives have the same output rates. This is only the case in TB, RL!  
* Output bound class: Chang only with TB, RL? TODO Check this up!

* Num interface: Add neq
    /**
     * Returns a copy of this curve that is shifted to the right by <code>dx</code>,
     * i.e. g(x) = f(x-dx).
     *
     * @param curve The curve to shift.
     * @param dx    The offset to shift the curve.
     * @return The shifted curve.
     */
    public static Curve shiftRight(Curve curve, Num dx) {
        Curve curve_copy = curve.copy();
        if (dx.equals(0.0)) {
            return curve_copy;
        }

        LinearSegment current_segment = curve_copy.getSegment( 0 );
        if( !current_segment.getX().equals( 0 )
        		|| !current_segment.getY().equals( 0 ) ) {
            throw new RuntimeException("Curve to shift right must pass through origin!");
        }
        
        if( current_segment.getGrad().greater( Num.getZero() ) ) {
        	 // Add a zero segment at the front
        	curve_copy.addSegment( 0, LinearSegmentFactory.createZeroSegment() );
        }	

        for( int i = 1; i < curve_copy.getSegmentCount(); i++ ) {
    		// TODO Needs a better way than modifying the result of a getter!
        	curve_copy.getSegments()[i].setX( Num.add( curve_copy.getSegments()[i].getX(), dx ) );
    	}

        curve_copy.beautify();
    	return curve_copy;
    }

PMOO:
// Compute sum of bursts
		for ( Flow f : cross_flow_substitutes )
		{
			ArrivalCurve bound = f.getArrivalCurve();
			ArrivalCurve current_tb = (ArrivalCurve) bound.getTBComponent( ((Integer) flow_tb_iter_map.get( f )).intValue() );
			sum_bursts = Num.add( sum_bursts, current_tb.getTBBurst() );
		}