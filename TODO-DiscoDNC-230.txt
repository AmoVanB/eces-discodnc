* Fix RationalBigInteger tests â€”> bigger EPSILON?
* Coverity Scan static analysis

* Remove TODO and FIXME labels from the code 


* Changelog


v2.3.1
------

    /**
     * Returns a copy of this curve that is shifted to the right by <code>dx</code>,
     * i.e. g(x) = f(x-dx).
     *
     * @param curve The curve to shift.
     * @param dx    The offset to shift the curve.
     * @return The shifted curve.
     */
    public static Curve shiftRight(Curve curve, Num dx) {
        Curve curve_copy = curve.copy();
        if (dx.equals(0.0)) {
            return curve_copy;
        }

//        if ( !((curve_copy.getSegment(0).getY().equals(Num.getZero())))) {
        LinearSegment current_segment = curve_copy.getSegment( 0 );
        if( !current_segment.getX().equals( 0 )
        		|| !current_segment.getY().equals( 0 ) ) {
            throw new RuntimeException("Curve to shift right must pass through origin!");
        }
        
        // Default behavior: Zero segments
//        result.getSegments()[0] = LinearSegmentFactory.createHorizontalLine(0.0);
//        result.getSegments()[0].setY(curve_copy.getSegment(0).getY()); // Decide what to do if pass thru origin req. dropped...
        
        Curve result;
        if( current_segment.getGrad().equals( 0 ) ) {
            // No need to add a zero segment at the front: Just copy the curve and shift the following segments to the right.
        	result = curve_copy;
        	
            for( int i = 1; i < result.getSegmentCount(); i++ ) {
        		// TODO Needs a better way than modifying the result of a getter!
            	result.getSegments()[i].setX( Num.add( result.getSegments()[i].getX(), dx ) );
        	}
        	
        } else {
            // Add a zero segment at the front, copy the others segments behind it while simultaneously shifting them. 
        	
        	// TODO Use CurveFactory to make it work with RTC Curve
        	result = new DiscoCurve( curve_copy.getSegmentCount() + 1 );
        	// Default behavior: A curve full of zero segments is returned. No need to do anything with the first segment.
        	
        	for( int i = 0; i < curve_copy.getSegmentCount(); i++ ) {
        		
            	current_segment = curve_copy.getSegment(i);
            	current_segment.setX( Num.add( current_segment.getX(), dx ) );
            	
        		// TODO A set method for segments is required here!
            	result.getSegments()[i+1] = current_segment;
        	}

        }

        result.beautify();
    	return result;
    }


// getBurst and getTBBurst
    /**
     * Returns the burstiness of this token bucket curve.<br>
     * Note: For performance reasons there are no sanity checks! Only
     * call this method on a valid token bucket curve!
     *
     * @return the burstiness
     */
    public Num getTBBurst() {
    	if( segments.length > 1 ) {		// Token Buckets pass through the origin
			return segments[1].getY().copy();
		} else {						// rate functions have burst 0
			return Num.createZero();
		}
    }
	
	public Num getBurst() {
		return fLimitRight( Num.getZero() );
	}